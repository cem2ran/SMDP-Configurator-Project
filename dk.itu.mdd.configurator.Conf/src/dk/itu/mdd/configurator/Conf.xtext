// automatically generated by Xtext
grammar dk.itu.mdd.configurator.Conf with org.eclipse.xtext.common.Terminals

import "platform:/resource/asd/model/modelMDD2.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
Model returns Model:
		 root=Feature_Impl
	;
	
Feature returns Feature:
	Feature_Impl | Grouped | Mandatory | Optional;

Solitary returns Solitary:
	Mandatory | Optional;
	
Constrain returns Constrain: //Binary | Unary;
	Conjunction ( {Binary.leftExp=current} Operator=DisjunctiveOperator rightExp=Conjunction )* ;
Conjunction returns Constrain: 
	Equality ( {Binary.leftExp=current} Operator=ConjunctiveOperator rightExp=Equality )* ;
Equality returns Constrain: 
	Comparison ( {Binary.leftExp=current} Operator=EqualityOperator rightExp=Comparison )* ;
Comparison returns Constrain: 
	Binary ( {Binary.leftExp=current} Operator=ComparativeOperator rightExp=Binary )* ;
Binary returns Constrain:
	Primary ({Binary.leftExp=current} rightExp=Primary )* ;	
Primary	returns Constrain: 
	  featureReference=[Grouped|QualifiedName]  | Unary | '(' Constrain ')';
Unary returns Constrain:
	{Unary} Operator=("!"|"-") exp=Primary;

QualifiedName:
    ID ('.' ID)*;

enum DisjunctiveOperator returns BinaryOperator:
	disjunction = '||'
;

enum ConjunctiveOperator returns BinaryOperator:
	conjunction = '&&'
;

enum EqualityOperator returns BinaryOperator:
	equals = '==' | notEquals = '!='
;	
	
enum ComparativeOperator returns BinaryOperator:
	greaterThan = '>' | lessThan = '<' | greaterOrEquals = '>=' | lessOrEquals = '<='
;	
	
Group returns Group:
	Or | Xor
	;
Attribute returns Attribute:
	CString | Number  | Range | CBoolean
;

Range : //maybe this should return a constrain? just syntactic sugar, desugaring to leftExp > value < rightExp
 name=EString

	lower = INT
	upper = INT
;

CString:
	name=EString
	value = EString
;

CBoolean:
	name = EString
	value = BOOLEAN
;

Number:
	 name=EString
	value = INT
;

EString returns ecore::EString:
 ID | NULL;
 
 


Feature_Impl returns Feature:
	'Feature'
	name=EString
		( BEGIN subfeature+=Solitary ( subfeature+=Solitary)* END)?
		( '[' constrains+=Constrain ( "," constrains+=Constrain)* ']' )?
		//('att' attributes+=Attribute ( "," attributes+=Attribute)* )?
		;

Grouped:
		name=EString
	    ( '('  attributes+=Attribute ( "," attributes+=Attribute)* ')' )?
		( '['  constrains+=Constrain ( "," constrains+=Constrain)* ']' )? 
	;

Mandatory:
	name=EString
		('{' subfeature+=Solitary ( "," subfeature+=Solitary)* '}' )?
		( '[' constrains+=Constrain ( "," constrains+=Constrain)* ']' )?
		( groups+=Group ( groups+=Group)* )?
	;

Optional:
	'?'
	name=EString
		('{' subfeature+=Solitary ( "," subfeature+=Solitary)* '}' )?
		('[' constrains+=Constrain ( "," constrains+=Constrain)* ']' )?
		( groups+=Group ( groups+=Group)* )?
	;



Or:
 	'Or' name=EString
		(BEGIN grouped+=Grouped ((',')* grouped+=Grouped)* END)?
	;

Xor:
	'Xor' name=EString
		(BEGIN grouped+=Grouped ((',')* grouped+=Grouped)* END)?
		;
	
terminal NULL: 'null';	
terminal BOOLEAN returns ecore::EBoolean: "true" | "false";
	
// The following synthetic tokens are used for the indentation-aware blocks
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation
	